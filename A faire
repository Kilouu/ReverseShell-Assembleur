ğŸ§  Ã‰tapes logiques dâ€™un reverse shell en assembleur

1. **CrÃ©er un socket**
    - Utiliser un appel systÃ¨me (`socket`) pour crÃ©er un socket TCP/IPv4.
    - En assembleur, cela passe par une configuration manuelle des registres pour appeler le bon syscall.

2. **Se connecter Ã  une adresse distante**
    - Utiliser le syscall `connect` pour Ã©tablir une connexion vers lâ€™IP et le port de lâ€™attaquant.
    - Cela nÃ©cessite de construire une structure `sockaddr_in` avec lâ€™adresse et le port (en format rÃ©seau).

3. **Rediriger les descripteurs de fichiers**
    - Utiliser `dup2` pour dupliquer le descripteur du socket versÂ :
      - `stdin` (0)
      - `stdout` (1)
      - `stderr` (2)
    - Ainsi, toute commande ou sortie passera par le rÃ©seau.

4. **ExÃ©cuter un shell**
    - Appeler `execve` (ou un Ã©quivalent) pour exÃ©cuter un shell, typiquement `/bin/sh`.
    - Cela permet Ã  lâ€™attaquant de taper des commandes comme sâ€™il Ã©tait en local.

---

âš ï¸ **ComplexitÃ© spÃ©cifique Ã  lâ€™assembleur**
- En assembleur, tout doit Ãªtre fait Ã  la mainÂ : prÃ©paration des registres, gestion de la pile, encodage des structures comme `sockaddr_in`, etc.
- Il faut aussi faire attention Ã Â :
  - Lâ€™alignement mÃ©moire.
  - Lâ€™absence de chaÃ®nes nulles si câ€™est dans un shellcode.
  - La taille du shellcode (si utilisÃ© Ã  des fins dâ€™injection).
